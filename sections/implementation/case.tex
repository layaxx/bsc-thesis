What does a case in the context of AngryBirds consist of?
The agent needs to know when a case can be applied. To achieve this, a qualitative description of the objects is used, which can be compared to a given scene.
The next component is a suggested solution, in this case a shot that can be executed in this situation.
Additionally, each case contains a description of the effects which the shot is expected to have on the objects, i.e. which objects should be destroyed and which should move.

\paragraph{The situation}
A description of the situation is necessary for the planner cato determine whether a given scenario is sufficiently similar for the case to provide meaningful input.
For the qualitative CBR, this description consists of a every object that had been affected by the original shot and a set of relations, that provide more information about the qualities of those objects and their relative positions.


\paragraph{The shot}
For the quantitative CBR, described in \ref{par:quantititve-cbr}, we had used the target coordinates of the original shot, which were then transformed to a matched scenario.
Because this transformation of coordinates will not happen during the qualitative CBR process, a shot is instead represented by the object the original shot had targeted.
A drawback of this approach is the inability to represent complex shots not directly targeting one object.
Examples of such complex shots would be rebound shots.

Additional information is added, as along with the target object, qualitative predicates about the shot are saved. These consist of a classification of the how and where the target was (supposed to be) hit, i.e. the impact angle and whether the exact target point was above, below or at the center of the target object.
The latter can only be estimated, however. Due to technical restrictions we can record where the agent was trying to hit the object, but not where the shot actually hit.
The impact angle of a shot shot is a value in $(-90;90)$. A shot that hits the target straight on has an impact angle of 0, while an angle of plus/minus 90 degree would correspond to a shot hitting the target directly from below/above respectively. Shots are categorized based on the absolute value of the impact angle according to: If it is less than 20 degree, the shot is called ``low'', if it is less than 40 degrees, it is ``medium'' and otherwise, the shot is classified as ``high''.

\asfigure{fig:classified-shots}{data/situation8-1.pdf}{Shots generated by the planner. Shots are classified, red corresponds to high, gray to medium and blue to low shot.}{15}


\paragraph{The Effects}
The effects describe how the original shot interacted with objects in the scene. An object can either be destroyed, moved or not affected at all by a shot. There are two main use cases for the expected effects a shot might have. The first is in the planning phase, where these might be used to determine whether this shot will improve the situation at hand, thus enabling complex planning processes for multiple shots in a row.

After executing a shot, the expected effects can be compared to the observed effects, checking for every object that should have been affected whether and how it was affected.
A complete match would be a situation in which every object that should have been destroyed was destroyed and every object that should have moved was moved. Depending on the circumstances, a case can still be considered a success even though not every object was affected as expected.
For example, if an object should have been moved but was actually destroyed, it is not a perfect match anymore, but depending on how the effects are used in the planning stage, this might or might not influence whether the shot was a success. Section \ref{subsec:experimental-predicates} discusses what under what conditions a case application is considered successful for the evaluation.
If the effects match closely even though the situation before the shot was not a perfect match, this can be used to update the case in order to loosen restrictions on the situation.

For example, if a case with large wooden objects has the same effects when the wooden objects are small, the restriction on size could either be removed entirely or could be loosened to either small or big, leaving medium objects out until they have been observed to work as well.
If the match was not perfect and the observed effects were different from expectations, a new case can be generated.

If, on the other hand, the situation before the shot did match well but the observed effects were notably different from expectation, the case restrictions could either be made more strict, or the entire case could be discarded.

Another option would be to associate cases with a confidence value which is increased once a case is successfully applied and decreased on failure.

\paragraph{When should a new case be added?}
This question goes back to an entirely different, not yet solved problem: Determining how good a shot was.
This is nontrivial, as a shot might not destroy a target but still improve the overall situation by removing obstacles and enabling better shots at remaining targets.
A shot that takes out a target might also not be a very good shot if it leads to other targets becoming obstructed and harder to hit.
Because classifying the quality of a shot is out of scope for this paper, we are assume that shots are good if they destroy at least one target.
When the agent has executed a shot that meets this criterion, on of two things can happen: The shot was already based on a CBR shot, then the underlying case can be updated based on the observed effects. Otherwise, the a new case is generated using this shot and its effects.

To avoid trivial shots, such as direct hits at a pig, which might only affect this one object and thus match every situation, shots are only added to the database if the target object is not a pig.

\begin{lstlisting}[caption=case information outside of Prolog]
{
  "targetID": "ice8",
  "birdType": "RedBird",
  "effects": {
    "movedIDs": ["ice28"],
    "destroyedIDs": ["ice7", "pig1", "ice8"]
  },
  "shotType": "MEDIUM",
  "optionalPredicates": [
    { "predicateName": "hasForm", "args": ["Ice8", "bar"] },
    //...
  ],
  "caseIndex": 5
}    
\end{lstlisting}

\begin{lstlisting}[label=lst:case-prolog, language=Prolog, caption=case information in Prolog]
case(cbr_5, [medium, center]).
testAssignment(cbr_5,[Ice8, Ice28, Ice7, Pig1],Conflicts, Score):-
    hittable(_,Ice8),
    find_conflicts([before(Ice28,Pig1,yAxis),hasForm(Ice7,block), //...
        ], Conflicts),
    length(Conflicts, CL),
    Score is 1 -(CL / 24).
randomAssignment(cbr_5, [Ice8, Ice28, Ice7, Pig1]):-
    findall(ID,object(ID,rect,ice),Icerect),
    random_permutation(Icerect, TargetIcerect),
    member(Ice8, TargetIcerect),
    hittable(_, Ice8),
    delete(TargetIcerect,Ice8, WithoutTarget),
    [Ice28,Ice7|_] = WithoutTarget,
    findall(ID,object(ID,ball,pork),Porkball),
    random_permutation([Pig1|_],Porkball),
true.
\end{lstlisting}